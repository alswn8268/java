package java_220824;

public class BitOperator {

	public static void main(String[] args) {
		
		int a = 10, b = 12;	// 0000 1010 ; 0000 1100
		
//		비트 연산자
//		최상위 비트는 부호 비트로 사용되며 0은 양수, 1은 음수이다.
//		&: 비트 and, 두 비트가 모두 1이면 1
//		|: 비트 or, 두 비트 중에서 1비트 이상 1이면 1
//		^: 비트 xor(배타적 논리합), 두 비트가 다를 때 1 
//		~: 비트 부정, 1은 0으로, 0은 1로, 1의 보수를 계산한다.
		System.out.println(a & b);	// 0000 1010 & 0000 1100 => 0000 1000 => 8
		System.out.println(a | b);	// 0000 1010 | 0000 1100 => 0000 1110 => 14
		System.out.println(a ^ b);	// 0000 1010 ^ 0000 1100 => 0000 0110 => 6

//		~00001010 => 11110101 => 부호 비트가 1이므로 음수 다시 2의 보수로 변환하면 => 00001011 => -11	
		System.out.println(~a);	//	
		System.out.println(~b);
			
//		9의 보수: 어떤 수가 있을 때 그 수에 얼마를 더해야 그 자리에 꽉 차는 수인가? => 컴퓨터에서는 1의 보수라 부른다.
//		10의 보수: 어떤 수가 있을 때 그 수에 얼마를 더해야 자리 올림이 발생하는 수인가? => 컴퓨터에서는 2의 보수라 부른다.
//		10의 보수는 9의 보수보다 1이 크다. => 2의 보수는 1의 보수보다 1이 크다.
		
//		고정 소수점: 2진 정수를 표현한다.
//		고정 소수점 표현 방법은 부호와 절대치, 1의 보수, 2의 보수 이렇게 3가지 방법이 있고 현재는 2의 보수법만 사용한다.
//		양수 표현 방법은 3가지 방법 모두 같고 음수 표현 방법이 각기 다르다.
		
//		부호와 절대치		+10	00001010	부호만 1로 변경하고 나머지는 그대로 쓴다.
//							-10 10001010
		
//		1의 보수			+10	00001010	양수를 1의 보수로 변환하면 음수가 된다.
//							-10	11110101

//		2의 보수			+10	00001010	양수를 2의 보수로 변환하면 음수가 된다.	(표현 범위가 더 넓음)
//							-10	11110110

//		+10	00001010
//		~10	11110101	최상위 비트가 1이므로 음수다.
//			00001011	숫자의 크기를 알아보려면 2의 보수로 재변환한다.
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
}
